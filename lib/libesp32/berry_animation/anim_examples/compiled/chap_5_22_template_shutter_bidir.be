# Generated Berry code from Animation DSL
# Source: chap_5_22_template_shutter_bidir.anim
# 
# This file was automatically generated by compile_all_examples.sh
# Do not edit manually - changes will be overwritten

import animation

# Template animation with flags
# Template animation class: shutter_bidir
class shutter_bidir_animation : animation.engine_proxy
  static var PARAMS = animation.enc_params({
    "colors": {"type": "palette"},
    "period": {"default": 2000},
    "ascending": {"type": "bool", "default": true},
    "descending": {"type": "bool", "default": true}
  })

  # Template setup method - overrides EngineProxy placeholder
  def setup_template()
    var engine = self   # using 'self' as a proxy to engine object (instead of 'self.engine')

    var strip_len_ = animation.strip_length(engine)
    # animated value for the size of the shutter, evolving linearly in time (sawtooth from 0% to 100%)
    var shutter_size_ = (def (engine)
      var provider = animation.sawtooth(engine)
      provider.min_value = 0
      provider.max_value = strip_len_
      provider.duration = animation.create_closure_value(engine, def (engine) return self.period end)
      return provider
    end)(engine)
    # define two rotating palettes, shifted by one color
    var col1_ = animation.color_cycle(engine)
    col1_.palette = animation.create_closure_value(engine, def (engine) return self.colors end)
    col1_.cycle_period = 0
    var col2_ = animation.color_cycle(engine)
    col2_.palette = animation.create_closure_value(engine, def (engine) return self.colors end)
    col2_.cycle_period = 0
    col2_.next = 1  # move 'col2' to the next color so it's shifte by one compared to 'col1'
    # shutter moving in ascending
    var shutter_lr_animation_ = animation.beacon_animation(engine)
    shutter_lr_animation_.color = col2_
    shutter_lr_animation_.back_color = col1_
    shutter_lr_animation_.pos = 0
    shutter_lr_animation_.beacon_size = shutter_size_
    shutter_lr_animation_.slew_size = 0
    shutter_lr_animation_.priority = 5
    # shutter moving in descending
    var shutter_rl_animation_ = animation.beacon_animation(engine)
    shutter_rl_animation_.color = col1_
    shutter_rl_animation_.back_color = col2_
    shutter_rl_animation_.pos = 0
    shutter_rl_animation_.beacon_size = animation.create_closure_value(engine, def (engine) return animation.resolve(strip_len_) - animation.resolve(shutter_size_) end)
    shutter_rl_animation_.slew_size = 0
    shutter_rl_animation_.priority = 5
    # this is the overall sequence composed of two sub-sequences
    # the first in ascending mode, the second in descending
    var shutter_seq_ = animation.sequence_manager(engine, -1)
          .push_repeat_subsequence(animation.sequence_manager(engine, def (engine) return bool(self.ascending) end)
            # conditional execution: run only if 'ascending' is true
            .push_repeat_subsequence(animation.sequence_manager(engine, def (engine) return col1_.palette_size end)
              # run the shutter animation
              .push_closure_step(def (engine) shutter_size_.start(engine.time_ms) end)  # resync all times for this animation, to avoid temporal drift
              .push_play_step(shutter_lr_animation_, def (engine) return self.period end)  # run the animation
              .push_closure_step(def (engine) col1_.next = 1 end)  # then move to next color for both palettes
              .push_closure_step(def (engine) col2_.next = 1 end)
              )
            )
          .push_repeat_subsequence(animation.sequence_manager(engine, def (engine) return bool(self.descending) end)
            # conditional execution: run only if 'descending' is true
            .push_repeat_subsequence(animation.sequence_manager(engine, def (engine) return col1_.palette_size end)
              .push_closure_step(def (engine) shutter_size_.start(engine.time_ms) end)
              .push_play_step(shutter_rl_animation_, def (engine) return self.period end)
              .push_closure_step(def (engine) col1_.next = 1 end)
              .push_closure_step(def (engine) col2_.next = 1 end)
              )
            )
    self.add(shutter_seq_)
  end
end

# define a palette of rainbow colors including white with constant brightness
# Auto-generated strip initialization (using Tasmota configuration)
var engine = animation.init_strip()

var rainbow_with_white_ = bytes(
  "FFFC0000"  # Red
  "FFFF8000"  # Orange
  "FFFFFF00"  # Yellow
  "FF00FF00"  # Green
  "FF00FFFF"  # Cyan
  "FF0080FF"  # Blue
  "FF8000FF"  # Violet
  "FFCCCCCC"  # White
)
var main_ = shutter_bidir_animation(engine)
main_.colors = rainbow_with_white_
main_.period = 1500
engine.add(main_)
engine.run()


#- Original DSL source:
# Template animation with flags

template animation shutter_bidir {
  param colors type palette
  param period default 2s
  param ascending type bool default true    # define to true to enable 'ascending' part
  param descending type bool default true   # define to true to enable 'descending' part

  # since 'strip_length()' is a value provider, it must be assigned to a variable before being used
  set strip_len = strip_length()

  # animated value for the size of the shutter, evolving linearly in time (sawtooth from 0% to 100%)
  set shutter_size = sawtooth(min_value = 0, max_value = strip_len, duration = period)

  # define two rotating palettes, shifted by one color
  color col1 = color_cycle(palette=colors, cycle_period=0)
  color col2 = color_cycle(palette=colors, cycle_period=0)
  col2.next = 1     # move 'col2' to the next color so it's shifte by one compared to 'col1'

  # shutter moving in ascending
  animation shutter_lr_animation = beacon_animation(
    color = col2
    back_color = col1
    pos = 0
    beacon_size = shutter_size
    slew_size = 0
    priority = 5
  )

  # shutter moving in descending
  animation shutter_rl_animation = beacon_animation(
    color = col1
    back_color = col2
    pos = 0
    beacon_size = strip_len - shutter_size
    slew_size = 0
    priority = 5
  )

  # this is the overall sequence composed of two sub-sequences
  # the first in ascending mode, the second in descending
  sequence shutter_seq repeat forever {
    if ascending {                              # conditional execution: run only if 'ascending' is true
      repeat col1.palette_size times {          # run the shutter animation
        restart shutter_size                    # resync all times for this animation, to avoid temporal drift
        play shutter_lr_animation for period    # run the animation
        col1.next = 1                           # then move to next color for both palettes
        col2.next = 1
      }
    }
    if descending {                             # conditional execution: run only if 'descending' is true
      repeat col1.palette_size times {
        restart shutter_size
        play shutter_rl_animation for period
        col1.next = 1
        col2.next = 1
      }
    }
  }
  
  run shutter_seq
}

# define a palette of rainbow colors including white with constant brightness
palette rainbow_with_white = [
  0xFC0000        # Red
  0xFF8000        # Orange
  0xFFFF00        # Yellow
  0x00FF00        # Green
  0x00FFFF        # Cyan
  0x0080FF        # Blue
  0x8000FF        # Violet
  0xCCCCCC        # White
]

animation main = shutter_bidir(colors = rainbow_with_white, period = 1.5s)
run main

-#
